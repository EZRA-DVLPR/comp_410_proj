1) using python functionality, we can inquire a user input for whether they would like to see another result or not. If the user opts to see another result, we would print the current result, return false in the code for the computed result and proceed the same as before. Otherwise, if the user opts not to see another result, then the currently computed result would be printed and also returned as true.

Using non-python functionality, it might be possible to pass a parameter that indicates whether all solutions would be found, or just one (a solution). This binary parameter would be passed through subsequent calls. If it is false then it would then get passed into the original function that we worked on in the file. If the parameter is true, then we would find the soln, and enter the solution into a Cons(the immutable Map, previous list of solutions). This would maintain the spirit of Prolog, whilst maintaining a similar structure to the code given to us.

2) To find an efficient generator of solutions, perhaps it would be best to run a DFS on the given formula converted into a tree. Each search would be for the smallest depths first. Then try to do those first in hopes of encountering a solution (true/fail) quickly so that memory can be used in a monotonically increasing fashion. Each failure would result in another branch being taken that has a depth of equal or larger size. A success would simply end the result. This would require extra work however of converting the given formula into a different data structure like an AST, then running the DFS algorithm, followed by actually evaluating the solution